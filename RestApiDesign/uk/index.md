# Архітектурний стиль REST

REST це _архітектурний стиль_ web сервісів. З точки зору лексикології, REST є акронімом для _REpresentational State Transfer_.

> [!NOTE]
> Архітектурний стиль можна розглядати як загальноприйнятий патерн, синонімом до _архітектурного стилю_ є _архітектурна парадигма_. Конкретний _архітектурний стиль_ може бути пояснено через його _дизайн-принципи_ (їх ще називають _design constraints_ або _архітектурні принципи_ чи _архітектурні обмеження_). Іншими словами, _архітектурний стиль_ є не що інше, як набір _архітектурних обмежень_ (тобто, ось це - має бути зроблено так і ніяк інакше).

_REpresentational State Transfer_ означає, що сервер і клієнт здійснюють комунікацію щодо стану ресурса. Коли сервер відправляє ресурс клієнту він каже: "ось крайня версія стану документа". Коли клієнт каже змінити документ, він каже серверу: "я хочу щоб ця версія документа (ось цей ресурс, який я тобі передаю) стала крайньою версією його стану".

> [!NOTE]
> По суті _ресурс_ це будь-яка інформація яка передається між клієнтом і сервером.

## Архітектурна парадигма REST базується на 6 принципах:

1. **Принцип клієнтсько-серверної архітектури**. В основі цього принципу лежить принцип _separation of concerns_: сервер відповідає за збереження даних, клієнт - за те як ці дані репрезентувати. І сервер і клієнт є абстракціями: клієнтом може бути web клієнт, мобільний додаток чи command line interface (або щось інше); сервером - сам сервер чи сервер з _layered конфігурацією_. Ні клієнт, ні сервер не знають, як протилежна абстракція реалізована.
1. **Принцип stateless**. Цей принцип означає, що кожен request містить усю потрібну інформацію. Тобто сервер отримавши request може, не чекаючи на якусь додаткову інформацію, почати одразу його виконувати.
1. **Принцип cacheability**. Цей принцип дозволяє кешування ресурсів. Наприклад, сервер дозволяє кешувати `GET` запит на `/api/series` (коли клієнт каже серверу: поверни мені усі доступні продукти, а саме усі доступні серіали - англ. series).
1. **Layered principle**. Принцип _шарування_ передбачає, що перед сервером з REST API може розташовуватись _балансувальник навантаження_ (англ. _load balancer_) чи _proxy_, чи скажімо _firewall_. Тобто запит відправлений на сервер спочатку потрапляє на _балансувальник навантаження_, який в свою чергу вирішує на який з доступних серверів його передати (використовується щоб зменшити навантаження на сервер і відповідно час очікування на відповідь від сервера).
1. **Принцип code on demand**. Цей принцип говорить, що REST API може повернути блок коду (наприклад, JavaScript), який за потреби може бути використаний клієнтом для розширення його функціональності.
1. **Принцип Uniform Інтерфейсу**. _Uniform Interface_ представляє собою project convention щодо певного стандарту комунікації клієнт-сервер. REST design передбачає формування такого стандарту на проекті (це може бути як загальноприйнятий стандарт, так і кастомний стандарт, сформований в залежності від requirements і деталей імплементації).

   REST design окреслює наступні ключі _Uniform Інтерфейсу_:

   - `UniformInterface.statusCodes` - для встановлення єдиного стандарту використання HTTP status codes на проекті.
   - `UniformInterface.verbs` - для встановлення єдиного стандарту використання _HTTP verbs_ (_HTTP keywords_) на проекті.
   - А також встановлення єдиного стандарту формування _URI_ (endpoints) - `UniformInterface.URIs`.

   Загальноприйнятий REST стандарт для HTTP response status codes передбачає обов'язкове визначення наступних груп статус кодів: `2xx` (success response), `4xx` (client error response) та `5xx` (server error response). Наприклад:

   - Група `2xx` статус кодів зазвичай включає наступні статус коди:

     - `200`. Request виконано успішно - це означає, що не мала місця ані помилка статус коду `400`, ані помилка статус коду `401`, ані помилка статус коду `500`).
     - `201` _created_. Цей статус код означає, що ресурс було створено (наприклад, клієнт робить запит на сервер додати ресурс до каталогу, сервер додає і вертає `201`).
     - `204` _no content_. Цей статус говорить, що запит успішно виконано і немає ніякої додаткової інформації для відправки на сервер. В цьому випадку статус `200` теж підходить і те, який статус буде використовуватись залежить від імплементації.

   - Група статус кодів `4xx` говорить про те, що проблема на стороні клієнта і для того, щоб її вирішити клієнт має щось робити інакше. Ця група зазвичай включає такі статус коди:

     - `404` - означає, що клієнт зробив технічно правильний request (сервер його розуміє), але не може знайти те, що запитує клієнт.
     - `400` _bad request_. Цей статус означає, що сервер не може зрозуміти request (request сформовано погано). Клієнту треба перевірити request. Цей статус код також може використовуватись у випадку коли клієнт намагається відправити на сервер файл, розмір якого є завеликим. З точки зору HTTP специфікації для цього випадку більш доречним буде код `413`. Але в контексті RESTful API може використовуватись і код `400` - все залежить від вимог до API на проекті та деталей імплементації.
     - `401` _unauthorized_. Цей код використовується, щоб повідомити клієнту що він не авторизований для даного запиту. Для виправлення цієї помилки, клієнту треба відправити валідні креди разом з запитом.

   - Статус коди групи `5xx` вказують, що помилка на сервері:

     - `500` _internal server error_. Ця помилка говорить, що на сервері щось пішло не так (це може бути практично будь що). Наприклад, код намагається доступитися до функції, яка не оголошена; чи код викидає exception, який не оброблено.

   Загальноприйнятий REST стандарт використання _HTTP verbs_ передбачає визначення єдиного стандарту використання 5 дієслів:

   - `GET`. Коли клієнт робить `GET` request, він просить сервер стягнути дані і відправити їх у відповідь клієнту. Все що має робити `GET` запит, це вертати дані, він не має дозволяти будь-які інші ефекти (як наприклад створення нового ресурсу в БД). Такі речі, як`ID` ресурса чи фільтр пошуку розміщуються в _URI_ (в _path variables_ та _query string params_ відповідно):
     - `GET` request на _URI_ `api/backpacks` вертає список речей.
     - У випадку `api/backpacks/123`, `GET` поверне single resource - рюкзак з `ID = 123` (англ. рюкзак).
     - `GET` request може бути і більш комплексним: `api/backpacks?price[val]=300&price[op]=lt`. В даному випадку це валідний `GET` запит для пошуку backpacks.
   - `POST`. В REST архітектурі `POST` request часто використовується для того, щоб створити новий об'єкт. В такому випадку цей новий об'єкт передається в тілі request. Часто в response, REST сервер вертає статус код `201`. `POST` request не передає в _URI_ `ID` ресурса, що треба створити.
   - `PUT`/`PATCH`. Коли потрібно здійснити update вже створеного ресурса, REST дизайн пропонує два _HTTP дієслова_ щоб це зробити: `PUT` та `PATCH`. Відмінність між ними полягає в тому, як вони здійснюють update ресурса. `PUT` здійснить update усього об'єкта, а `PATCH` здійснить update тільки тих полів, які були передані в запиті:
     - `PUT`. Очікується, що разом з `PUT` запитом клієнт має відправити дані до API (подібно до `POST`). Але на відміну від `POST` _URI_, яке використовує `PUT` буде дещо іншим: `api/backpacks/123`.
